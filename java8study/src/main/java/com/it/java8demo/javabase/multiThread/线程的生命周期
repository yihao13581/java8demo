    线程的生命周期中，包括；新建（New)、就绪(Runnable)、运行(Running)、阻塞(Blocked)和死亡(Dead)5中状态。
        当程序使用了new关键字创建了一个线程后，该线程就处于新建状态。当调用线程对象的start()方法之后，该线
    程立即进入就绪状态；处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，线程就处于运行状态。
        当发生如下情况下，线程会进入阻塞状态：1、线程调用sleep（）方法主动放弃所占用的处理器资源；2、线程
    调用了一个阻塞式IO方法，在该方法返回去前，该线程被阻塞；3、线程试图获得一个同步监视器，但该同步监视器正
    在被其它线程所持有。4、线程在等待某个通知(notify)。5、程序调用了线程的suspend()方法将该线程挂起（容易
    造成死锁）。
        线程死亡----线程会以如下三种方式结束，结束后就处于死亡状态：1、run()或call()方法执行完成，线程正常结束。
    2、线程抛出一个未捕获的Exception或error。3、直接调用该线程的stop()方法来结束该线程(该方法容易造成死锁，不推荐)
        测试线程是否已经死亡，可以调用线程对象的isAlive()方法，当线程处于就绪、运行、阻塞三种状态时，该方法返回true
    当线程处于新建、死亡状态时，该方法返回false。只能对新建状态的线程调用start()方法，否则引发IllegalThreadStateException异常。
        线程的分类：      join线程--Thread提供了让一个线程等待另一个线程完成的方法--join方法。当在某个线程执行流中调用
    其它线程的join()方法时，调用线程将被阻塞，直到被join()方法加入的join线程执行完毕。
                          后台进程（守护进程/精灵进程）：后台运行的线程，它的任务是为其它的线程提供服务。JVM的垃圾回收
    线程就是典型的后台进程。特征：所有的前台线程都死亡，后台线程会自动死亡。setDaemon(true)设置后台线程必须在start()之前。

        线程睡眠：sleep()
        线程让步：yield():让当前正在执行的线程暂停，但不会阻塞线程。只是让该线程转入就绪状态。让系统的线程调度重新调度一次，让具有更高
    优先级的就绪状态的线程获得执行的机会。
        线程的优先级：可以使用Thread的三个静态常量：MAX_PRIORITY:其值为10；MIN_PRIORITY:其值为1；NORM_PRIORITY;其值为5（默认情况下
    main线程以及由main线程创建的子线程也具有普通优先级。）
